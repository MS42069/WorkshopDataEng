pipeline {
    agent any

    environment {
        DOCKER_IMAGE_NAME_SUFFIX = 'stundenplan-frontend'
        DOCKER_LOGIN_CREDENTIALS = credentials('jenkins-docker-login-credentials')
        DOCKER_LOGIN_USER = credentials('jenkins-docker-login-user')
        NOMAD_TOKEN = credentials('nomad-secret-id')
        NOMAD_WEBSITE_JOB = 'stundenplan-website'
        NOMAD_FRONTEND_TASK = 'proxy'
    }

    stages {
        stage('Pre Build') {
            steps {
                step([$class: 'GitHubSetCommitStatusBuilder'])

                sh '''
                    echo 'Logging into docker ...'
                    echo "${DOCKER_LOGIN_CREDENTIALS}" | docker login ghcr.io -u "${DOCKER_LOGIN_USER}" --password-stdin
                '''
            }
        }

        stage('NPM Build') {
            steps {
                nodejs(nodeJSInstallationName: 'Node 16.x') {
                    sh '''
                        npm install
                        CI= npm run build
                    '''
                }
            }
        }

        stage('Docker') {
            steps {
                sh '''
                    GIT_COMMIT_HASH=$(git log -n 1 --pretty=format:'%H')
                    echo "Git commit hash: ${GIT_COMMIT_HASH}"
                    DOCKER_IMAGE_NAME="ghcr.io/${DOCKER_LOGIN_USER}/${DOCKER_IMAGE_NAME_SUFFIX}"
                    echo "Using docker image name: ${DOCKER_IMAGE_NAME}"
                    echo 'Building docker image ...'
                    docker pull nginx:mainline-alpine
                    docker build --build-arg "GIT_COMMIT=${GIT_COMMIT_HASH}" \
                        -f docker/ci.Dockerfile . \
                        -t "${DOCKER_IMAGE_NAME}:latest" \
                        -t "${DOCKER_IMAGE_NAME}:${GIT_COMMIT_HASH}"

                    echo 'Pushing images to the registry ...'
                    docker push "${DOCKER_IMAGE_NAME}:latest";
                    docker push "${DOCKER_IMAGE_NAME}:${GIT_COMMIT_HASH}";
                    echo 'Pushed docker images to the registry'
                '''
            }
        }

        stage('Deploy') {
            steps {
                script {
                    sh "echo 'Get current job configuration from nomad'"
                    def nomadJobConfigStr = sh(
                        script: 'nomad job inspect "${NOMAD_WEBSITE_JOB}"',
                        returnStdout: true
                    )

                    echo 'Parse backend job configuration'
                    def nomadJobConfig = readJSON text: nomadJobConfigStr
                    assert nomadJobConfig.containsKey('Job')
                    def nomadJob = nomadJobConfig['Job']
                    def tasks = nomadJob['TaskGroups'][0]['Tasks']
                    def frontendTask = tasks.find {task -> task['Name'] == env.NOMAD_FRONTEND_TASK}
                    assert frontendTask != null
                    def frontendTaskConfig = frontendTask['Config']

                    def gitCommitHash = sh(
                        script: "git log -n 1 --pretty=format:'%H'",
                        returnStdout: true
                    )
                    def dockerImage="ghcr.io/${DOCKER_LOGIN_USER}/${DOCKER_IMAGE_NAME_SUFFIX}:${gitCommitHash}"
                    echo "Using docker image ${dockerImage}"
                    frontendTaskConfig.put('image', dockerImage.toString())

                    writeJSON(file: 'nomad.json', json: nomadJob)
                    sh'''
                        echo 'Deploy new version with nomad'
                        nomad job run -json nomad.json
                        echo 'Successfully deployed application'
                    '''
                }
            }
        }
    }

    post {
        // Clean after build
        always {
            cleanWs(cleanWhenNotBuilt: false,
                    deleteDirs: true,
                    disableDeferredWipeout: true,
                    notFailBuild: true,
                    patterns: [[pattern: '.gitignore', type: 'INCLUDE'],
                               [pattern: '.propsfile', type: 'EXCLUDE']])
        }

        success {
            step([$class: 'GitHubCommitStatusSetter'])
        }

        unsuccessful {
            step([$class: 'GitHubCommitStatusSetter',
                statusResultSource: [$class: 'ConditionalStatusResultSource',
                    results: [
                        [$class: 'AnyBuildResult', state: 'FAILED', message: "Build failed"]
                    ]
                ]
            ])
        }
    }
}